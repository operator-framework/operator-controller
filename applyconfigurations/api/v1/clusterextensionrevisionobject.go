/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by controller-gen-v0.20. DO NOT EDIT.

package v1

import (
	apiv1 "github.com/operator-framework/operator-controller/api/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// ClusterExtensionRevisionObjectApplyConfiguration represents a declarative configuration of the ClusterExtensionRevisionObject type for use
// with apply.
//
// ClusterExtensionRevisionObject represents a Kubernetes object to be applied as part
// of a phase, along with its collision protection settings.
type ClusterExtensionRevisionObjectApplyConfiguration struct {
	// object is a required embedded Kubernetes object to be applied.
	//
	// This object must be a valid Kubernetes resource with apiVersion, kind, and metadata fields.
	Object *unstructured.Unstructured `json:"object,omitempty"`
	// collisionProtection controls whether the operator can adopt and modify objects
	// that already exist on the cluster.
	//
	// Allowed values are: "Prevent", "IfNoController", and "None".
	//
	// When set to "Prevent", the operator only manages objects it created itself.
	// This prevents ownership collisions.
	//
	// When set to "IfNoController", the operator can adopt and modify pre-existing objects
	// that are not owned by another controller.
	// This is useful for taking over management of manually-created resources.
	//
	// When set to "None", the operator can adopt and modify any pre-existing object, even if
	// owned by another controller.
	// Use this setting with extreme caution as it may cause multiple controllers to fight over
	// the same resource, resulting in increased load on the API server and etcd.
	//
	// When omitted, the value is inherited from the phase, then spec.
	CollisionProtection *apiv1.CollisionProtection `json:"collisionProtection,omitempty"`
}

// ClusterExtensionRevisionObjectApplyConfiguration constructs a declarative configuration of the ClusterExtensionRevisionObject type for use with
// apply.
func ClusterExtensionRevisionObject() *ClusterExtensionRevisionObjectApplyConfiguration {
	return &ClusterExtensionRevisionObjectApplyConfiguration{}
}

// WithObject sets the Object field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Object field is set to the value of the last call.
func (b *ClusterExtensionRevisionObjectApplyConfiguration) WithObject(value unstructured.Unstructured) *ClusterExtensionRevisionObjectApplyConfiguration {
	b.Object = &value
	return b
}

// WithCollisionProtection sets the CollisionProtection field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the CollisionProtection field is set to the value of the last call.
func (b *ClusterExtensionRevisionObjectApplyConfiguration) WithCollisionProtection(value apiv1.CollisionProtection) *ClusterExtensionRevisionObjectApplyConfiguration {
	b.CollisionProtection = &value
	return b
}
