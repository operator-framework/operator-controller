/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by controller-gen-v0.20. DO NOT EDIT.

package v1

import (
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// ClusterExtensionStatusApplyConfiguration represents a declarative configuration of the ClusterExtensionStatus type for use
// with apply.
//
// ClusterExtensionStatus defines the observed state of a ClusterExtension.
type ClusterExtensionStatusApplyConfiguration struct {
	// conditions represents the current state of the ClusterExtension.
	//
	// The set of condition types which apply to all spec.source variations are Installed and Progressing.
	//
	// The Installed condition represents whether the bundle has been installed for this ClusterExtension:
	// - When Installed is True and the Reason is Succeeded, the bundle has been successfully installed.
	// - When Installed is False and the Reason is Failed, the bundle has failed to install.
	//
	// The Progressing condition represents whether or not the ClusterExtension is advancing towards a new state.
	// When Progressing is True and the Reason is Succeeded, the ClusterExtension is making progress towards a new state.
	// When Progressing is True and the Reason is Retrying, the ClusterExtension has encountered an error that could be resolved on subsequent reconciliation attempts.
	// When Progressing is False and the Reason is Blocked, the ClusterExtension has encountered an error that requires manual intervention for recovery.
	// <opcon:experimental:description>
	// When Progressing is True and Reason is RollingOut, the ClusterExtension has one or more ClusterExtensionRevisions in active roll out.
	// </opcon:experimental:description>
	//
	// When the ClusterExtension is sourced from a catalog, it surfaces deprecation conditions based on catalog metadata.
	// These are indications from a package owner to guide users away from a particular package, channel, or bundle:
	// - BundleDeprecated is True if the installed bundle is marked deprecated, False if not deprecated, or Unknown if no bundle is installed yet or if catalog data is unavailable.
	// - ChannelDeprecated is True if any requested channel is marked deprecated, False if not deprecated, or Unknown if catalog data is unavailable.
	// - PackageDeprecated is True if the requested package is marked deprecated, False if not deprecated, or Unknown if catalog data is unavailable.
	// - Deprecated is a rollup condition that is True when any deprecation exists, False when none exist, or Unknown when catalog data is unavailable.
	Conditions []metav1.ConditionApplyConfiguration `json:"conditions,omitempty"`
	// install is a representation of the current installation status for this ClusterExtension.
	Install *ClusterExtensionInstallStatusApplyConfiguration `json:"install,omitempty"`
	// activeRevisions holds a list of currently active (non-archived) ClusterExtensionRevisions,
	// including both installed and rolling out revisions.
	// <opcon:experimental>
	ActiveRevisions []RevisionStatusApplyConfiguration `json:"activeRevisions,omitempty"`
}

// ClusterExtensionStatusApplyConfiguration constructs a declarative configuration of the ClusterExtensionStatus type for use with
// apply.
func ClusterExtensionStatus() *ClusterExtensionStatusApplyConfiguration {
	return &ClusterExtensionStatusApplyConfiguration{}
}

// WithConditions adds the given value to the Conditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Conditions field.
func (b *ClusterExtensionStatusApplyConfiguration) WithConditions(values ...*metav1.ConditionApplyConfiguration) *ClusterExtensionStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithConditions")
		}
		b.Conditions = append(b.Conditions, *values[i])
	}
	return b
}

// WithInstall sets the Install field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Install field is set to the value of the last call.
func (b *ClusterExtensionStatusApplyConfiguration) WithInstall(value *ClusterExtensionInstallStatusApplyConfiguration) *ClusterExtensionStatusApplyConfiguration {
	b.Install = value
	return b
}

// WithActiveRevisions adds the given value to the ActiveRevisions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ActiveRevisions field.
func (b *ClusterExtensionStatusApplyConfiguration) WithActiveRevisions(values ...*RevisionStatusApplyConfiguration) *ClusterExtensionStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithActiveRevisions")
		}
		b.ActiveRevisions = append(b.ActiveRevisions, *values[i])
	}
	return b
}
