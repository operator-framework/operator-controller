/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by controller-gen-v0.20. DO NOT EDIT.

package v1

import (
	apismetav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// ClusterCatalogStatusApplyConfiguration represents a declarative configuration of the ClusterCatalogStatus type for use
// with apply.
//
// ClusterCatalogStatus defines the observed state of ClusterCatalog
type ClusterCatalogStatusApplyConfiguration struct {
	// conditions represents the current state of this ClusterCatalog.
	//
	// The current condition types are Serving and Progressing.
	//
	// The Serving condition represents whether the catalog contents are being served via the HTTP(S) web server:
	// - When status is True and reason is Available, the catalog contents are being served.
	// - When status is False and reason is Unavailable, the catalog contents are not being served because the contents are not yet available.
	// - When status is False and reason is UserSpecifiedUnavailable, the catalog contents are not being served because the catalog has been intentionally marked as unavailable.
	//
	// The Progressing condition represents whether the ClusterCatalog is progressing or is ready to progress towards a new state:
	// - When status is True and reason is Retrying, an error occurred that may be resolved on subsequent reconciliation attempts.
	// - When status is True and reason is Succeeded, the ClusterCatalog has successfully progressed to a new state and is ready to continue progressing.
	// - When status is False and reason is Blocked, an error occurred that requires manual intervention for recovery.
	//
	// If the system initially fetched contents and polling identifies updates, both conditions can be active simultaneously:
	// - The Serving condition remains True with reason Available because the previous contents are still served via the HTTP(S) web server.
	// - The Progressing condition is True with reason Retrying because the system is working to serve the new version.
	Conditions []metav1.ConditionApplyConfiguration `json:"conditions,omitempty"`
	// resolvedSource contains information about the resolved source based on the source type.
	ResolvedSource *ResolvedCatalogSourceApplyConfiguration `json:"resolvedSource,omitempty"`
	// urls contains the URLs that can be used to access the catalog.
	URLs *ClusterCatalogURLsApplyConfiguration `json:"urls,omitempty"`
	// lastUnpacked represents the last time the catalog contents were extracted from their source format.
	// For example, when using an Image source, the OCI image is pulled and image layers are written to a file-system backed cache.
	// This extraction from the source format is called "unpacking".
	LastUnpacked *apismetav1.Time `json:"lastUnpacked,omitempty"`
}

// ClusterCatalogStatusApplyConfiguration constructs a declarative configuration of the ClusterCatalogStatus type for use with
// apply.
func ClusterCatalogStatus() *ClusterCatalogStatusApplyConfiguration {
	return &ClusterCatalogStatusApplyConfiguration{}
}

// WithConditions adds the given value to the Conditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Conditions field.
func (b *ClusterCatalogStatusApplyConfiguration) WithConditions(values ...*metav1.ConditionApplyConfiguration) *ClusterCatalogStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithConditions")
		}
		b.Conditions = append(b.Conditions, *values[i])
	}
	return b
}

// WithResolvedSource sets the ResolvedSource field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ResolvedSource field is set to the value of the last call.
func (b *ClusterCatalogStatusApplyConfiguration) WithResolvedSource(value *ResolvedCatalogSourceApplyConfiguration) *ClusterCatalogStatusApplyConfiguration {
	b.ResolvedSource = value
	return b
}

// WithURLs sets the URLs field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the URLs field is set to the value of the last call.
func (b *ClusterCatalogStatusApplyConfiguration) WithURLs(value *ClusterCatalogURLsApplyConfiguration) *ClusterCatalogStatusApplyConfiguration {
	b.URLs = value
	return b
}

// WithLastUnpacked sets the LastUnpacked field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LastUnpacked field is set to the value of the last call.
func (b *ClusterCatalogStatusApplyConfiguration) WithLastUnpacked(value apismetav1.Time) *ClusterCatalogStatusApplyConfiguration {
	b.LastUnpacked = &value
	return b
}
